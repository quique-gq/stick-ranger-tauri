import { EventCallback, UnlistenFn } from './event';
interface WindowDef {
    label: string;
}
declare global {
    interface Window {
        __TAURI__: {
            __windows: WindowDef[];
            __currentWindow: WindowDef;
        };
    }
}
declare function getCurrent(): WebviewWindowHandle;
declare function getAll(): WindowDef[];
declare class WebviewWindowHandle {
    label: string;
    listeners: {
        [key: string]: Array<EventCallback<any>>;
    };
    constructor(label: string);
    /**
     * Listen to an event emitted by the webview.
     *
     * @param event Event name
     * @param handler Event handler callback
     * @returns A promise resolving to a function to unlisten to the event.
     */
    listen<T>(event: string, handler: EventCallback<T>): Promise<UnlistenFn>;
    /**
     * Listen to an one-off event emitted by the webview.
     *
     * @param event Event name
     * @param handler Event handler callback
     * @returns A promise resolving to a function to unlisten to the event.
     */
    once<T>(event: string, handler: EventCallback<T>): Promise<UnlistenFn>;
    /**
     * Emits an event to the webview.
     *
     * @param event Event name
     * @param [payload] Event payload
     */
    emit(event: string, payload?: string): Promise<void>;
    _handleTauriEvent<T>(event: string, handler: EventCallback<T>): boolean;
}
declare class WebviewWindow extends WebviewWindowHandle {
    constructor(label: string, options?: WindowOptions);
    /**
     * Gets the WebviewWindow handle for the webview associated with the given label.
     *
     * @param label The webview window label.
     * @returns The handle to communicate with the webview or null if the webview doesn't exist.
     */
    static getByLabel(label: string): WebviewWindowHandle | null;
}
export declare class WindowManager {
    /**
     * Updates the window resizable flag.
     *
     * @param resizable
     * @returns
     */
    setResizable(resizable: boolean): Promise<void>;
    /**
     * Sets the window title.
     *
     * @param title The new title
     * @returns
     */
    setTitle(title: string): Promise<void>;
    /**
     * Maximizes the window.
     *
     * @returns
     */
    maximize(): Promise<void>;
    /**
     * Unmaximizes the window.
     *
     * @returns
     */
    unmaximize(): Promise<void>;
    /**
     * Minimizes the window.
     *
     * @returns
     */
    minimize(): Promise<void>;
    /**
     * Unminimizes the window.
     *
     * @returns
     */
    unminimize(): Promise<void>;
    /**
     * Sets the window visibility to true.
     *
     * @returns
     */
    show(): Promise<void>;
    /**
     * Sets the window visibility to false.
     *
     * @returns
     */
    hide(): Promise<void>;
    /**
     * Closes the window.
     *
     * @returns
     */
    close(): Promise<void>;
    /**
     * Whether the window should have borders and bars.
     *
     * @param decorations Whether the window should have borders and bars
     * @returns
     */
    setDecorations(decorations: boolean): Promise<void>;
    /**
     * Whether the window should always be on top of other windows.
     *
     * @param alwaysOnTop Whether the window should always be on top of other windows or not
     * @returns
     */
    setAlwaysOnTop(alwaysOnTop: boolean): Promise<void>;
    /**
     * Sets the window width.
     *
     * @param width The new window width
     * @returns
     */
    setWidth(width: number): Promise<void>;
    /**
     * Sets the window height.
     *
     * @param height The new window height
     * @returns
     */
    setHeight(height: number): Promise<void>;
    /**
     * Resizes the window.
     *
     * @param width The new window width
     * @param height The new window height
     * @returns
     */
    resize(width: number, height: number): Promise<void>;
    /**
     * Sets the window min size.
     *
     * @param minWidth The new window min width
     * @param minHeight The new window min height
     * @returns
     */
    setMinSize(minWidth: number, minHeight: number): Promise<void>;
    /**
     * Sets the window max size.
     *
     * @param maxWidth The new window max width
     * @param maxHeight The new window max height
     * @returns
     */
    setMaxSize(maxWidth: number, maxHeight: number): Promise<void>;
    /**
     * Sets the window x position.
     *
     * @param x The new window x position
     * @returns
     */
    setX(x: number): Promise<void>;
    /**
     * Sets the window y position.
     *
     * @param y The new window y position
     * @returns
     */
    setY(y: number): Promise<void>;
    /**
     * Sets the window position.
     *
     * @param x The new window x position
     * @param y The new window y position
     * @returns
     */
    setPosition(x: number, y: number): Promise<void>;
    /**
     * Sets the window fullscreen state.
     *
     * @param fullscreen Whether the window should go to fullscreen or not
     * @returns
     */
    setFullscreen(fullscreen: boolean): Promise<void>;
    /**
     * Sets the window icon.
     *
     * @param icon Icon bytes or path to the icon file
     * @returns
     */
    setIcon(icon: string | number[]): Promise<void>;
}
declare const appWindow: WindowManager;
export interface WindowOptions {
    url?: string;
    x?: number;
    y?: number;
    width?: number;
    height?: number;
    minWidth?: number;
    minHeight?: number;
    maxWidth?: number;
    maxHeight?: number;
    resizable?: boolean;
    title?: string;
    fullscreen?: boolean;
    maximized?: boolean;
    visible?: boolean;
    decorations?: boolean;
    alwaysOnTop?: boolean;
}
export { WebviewWindow, getCurrent, getAll, appWindow };
